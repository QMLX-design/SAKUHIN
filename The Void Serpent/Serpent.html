<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Art - The Old One</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #020202; overflow: hidden;
            font-family: 'Courier New', monospace; user-select: none;
        }
        canvas { display: block; }

        /* UI */
        #ui {
            position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10;
        }
        h1 {
            color: #fff; font-size: 20px; margin: 0 0 5px 0; letter-spacing: 4px;
            text-transform: uppercase; text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }
        #stage-info { color: #888; font-size: 12px; margin-bottom: 8px; }
        #exp-container { width: 200px; height: 3px; background: #111; }
        #exp-fill {
            width: 0%; height: 100%; background: #fff;
            box-shadow: 0 0 10px #fff; transition: width 0.2s;
        }

        /* 底部提示 */
        #hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.2); font-size: 12px; pointer-events: none;
        }

        /* 控制面板 */
        #settings-panel {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(5, 10, 5, 0.9); border: 1px solid #333;
            padding: 15px; color: #ccc; font-size: 12px;
            backdrop-filter: blur(8px); transition: opacity 0.3s;
            z-index: 100; /* ★★★ 强制置顶，高于 Shader 画布 ★★★ */
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; color: #666; }
        .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: #444; }
        .control-group span { float: right; color: #fff; }

        .stage-btns { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
        .stage-btn {
            background: #111; border: 1px solid #333; color: #666;
            padding: 6px 0; cursor: pointer; font-family: inherit; font-size: 10px;
        }
        .stage-btn:hover { background: #222; color: #fff; }
        .stage-btn.active { background: #fff; color: #000; border-color: #fff; }
        .stage-btn:nth-child(7) { border-color: #f22; color: #f22; font-weight: bold; }
        .stage-btn:nth-child(7).active { background: #f22; color: #000; box-shadow: 0 0 15px #f00; }

        .hidden { opacity: 0; pointer-events: none; }

        /* 闪白特效层 */
        #flash-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none;
            transition: opacity 1.5s ease-out; z-index: 100;
        }
    </style>
</head>
<body>

<div id="flash-overlay"></div>

<div id="ui">
    <h1 id="title">ENTITY</h1>
    <div id="stage-info">Phase I: SPORE</div>
    <div id="exp-container"><div id="exp-fill"></div></div>
</div>

<div id="settings-panel" style="z-index: 100;"> <div style="margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:5px;">
        <strong>CONTROL PANEL (Press 'H')</strong>
    </div>

    <div style="margin-bottom:15px; border-bottom:1px solid #222; padding-bottom:10px;">
        <div style="font-size:10px; color:#888; margin-bottom:5px;">AUDIO MIXER</div>

        <div class="control-group" style="margin-bottom:5px;">
            <label style="font-size:10px;">BGM (Ambient)</label>
            <input type="range" id="vol-ambient" min="0" max="1.5" step="0.1" value="0.8">
        </div>

        <div class="control-group" style="margin-bottom:5px;">
            <label style="font-size:10px;">SFX: Spawn</label>
            <input type="range" id="vol-spawn" min="0" max="1.5" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label style="font-size:10px;">SFX: Eat</label>
            <input type="range" id="vol-eat" min="0" max="1.5" step="0.1" value="0.5">
        </div>
    </div>

    <div class="control-group">
        <label>Max Food: <span id="val-food">1</span></label>
        <input type="range" id="inp-food" min="1" max="10" value="1" step="1">
    </div>

    <div class="control-group">
        <label>Exp per Stage: <span id="val-exp">5</span></label>
        <input type="range" id="inp-exp" min="1" max="50" value="5" step="1">
    </div>

    <div class="control-group">
        <label>Force Stage:</label>
        <div class="stage-btns">
            <button class="stage-btn active" onclick="setStage(0)">I</button>
            <button class="stage-btn" onclick="setStage(1)">II</button>
            <button class="stage-btn" onclick="setStage(2)">III</button>
            <button class="stage-btn" onclick="setStage(3)">IV</button>
            <button class="stage-btn" onclick="setStage(4)">V</button>
            <button class="stage-btn" onclick="setStage(5)">VI</button>
            <button class="stage-btn" onclick="setStage(6)">VII</button>
        </div>
    </div>
</div>

<div id="hint">点击投喂 · Click to Feed</div>
<canvas id="canvas"></canvas>

<script src="Void Audio Engine.js"></script>

<script src="shader.js"></script>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uiExp = document.getElementById('exp-fill');
    const uiStage = document.getElementById('stage-info');
    const uiTitle = document.getElementById('title');
    const panel = document.getElementById('settings-panel');
    const flashOverlay = document.getElementById('flash-overlay');
    const inpFood = document.getElementById('inp-food');
    const valFood = document.getElementById('val-food');
    const volAmbient = document.getElementById('vol-ambient');
    const volSpawn = document.getElementById('vol-spawn');
    const volEat = document.getElementById('vol-eat');
    const inpExp = document.getElementById('inp-exp');
    const valExp = document.getElementById('val-exp');
    const stageBtns = document.querySelectorAll('.stage-btn');
    if (volAmbient) { // 加个简单的检查是个好习惯
    volAmbient.addEventListener('input', e => {
        if(audio) audio.setVolume('ambient', e.target.value);
    });
    volSpawn.addEventListener('input', e => {
        if(audio) audio.setVolume('spawn', e.target.value);
    });
    volEat.addEventListener('input', e => {
        if(audio) audio.setVolume('eat', e.target.value);
    });
}


    let width, height, time = 0;

    // --- 核心配置 ---
    let config = {
        maxFood: 3,       // 默认只能投喂1个
        expPerStage: 8,   // 默认5个食物升一级
        spineCount: 80
    };

    let currentExp = 0, stage = 0;
    let morphFactor = 0;
    let hasDescended = false;

    const stages = [
        { name: "SPORE",   legLen: 10,  width: 2,  spike: 0,   hue: 0,   sat: 0,   light: 50, glow: 0,  tendrilLen: 0,   headSize: 3, chaos: 0, faceTentacles: 0, CthulhuForm: false },
        { name: "LARVA",   legLen: 40,  width: 10, spike: 0,   hue: 170, sat: 80,  light: 60, glow: 5,  tendrilLen: 0,   headSize: 6, chaos: 0, faceTentacles: 0, CthulhuForm: false },
        { name: "HUNTER",  legLen: 70,  width: 20, spike: 0.8, hue: 0,   sat: 90,  light: 50, glow: 15, tendrilLen: 0,   headSize: 8, chaos: 0, faceTentacles: 0, CthulhuForm: false },
        { name: "MUTANT",  legLen: 100, width: 15, spike: 1.5, hue: 280, sat: 90,  light: 60, glow: 20, tendrilLen: 100, headSize: 10, chaos: 2, faceTentacles: 0, CthulhuForm: false },
        { name: "DIVINE",  legLen: 180, width: 5,  spike: 0,   hue: 45,  sat: 100, light: 90, glow: 60, tendrilLen: 450, headSize: 15, chaos: 0, faceTentacles: 0, CthulhuForm: false },
        { name: "ABOMINATION", legLen: 120, width: 40, spike: 2.0, hue: 140, sat: 90, light: 40, glow: 30, tendrilLen: 600, headSize: 25, chaos: 5, faceTentacles: 1, CthulhuForm: false },
        { name: "TRUE CTHULHU", legLen: 50, width: 60, spike: 3.0, hue: 150, sat: 80, light: 30, glow: 50, tendrilLen: 800, headSize: 40, chaos: 8, faceTentacles: 2.5, CthulhuForm: true }
    ];

    let render = { ...stages[0] };

    let spine = [], foods = [], particles = [], shockwaves = [];
    let tendrilL = [], tendrilR = [];
    let cthulhuCenter = { x: 0, y: 0 };

    // ★★★ 1. 声明 Shader 变量 ★★★
    let postProcessor = null;

    // 初始化音频 (检查是否存在，防止报错)
    let audio = null;
    try {
        if (typeof AudioEngine !== 'undefined') {
            audio = new AudioEngine();
        } else {
            console.warn("Void Audio Engine.js not found. Audio disabled.");
        }
    } catch (e) { console.warn("Audio init failed:", e); }

    // 1. 新增：专门处理窗口大小调整的函数
        function resize() {
            const dpr = window.devicePixelRatio || 1; // 高清屏适配
            width = window.innerWidth;
            height = window.innerHeight;

            // 设置物理分辨率
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            // 设置 CSS 尺寸
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr); // 统一缩放

            // 如果 Shader 存在，也让它调整大小
            if (postProcessor) postProcessor.resize();
        }

        // 2. 修改后的 init：只做一次性初始化
        function init() {
            resize(); // 先设置好尺寸

            // 生成骨骼 (这些代码以后 resize 时不会再执行，所以不会重置了)
            spine = []; tendrilL = []; tendrilR = [];
            for(let i=0; i<config.spineCount; i++) {
                let pt = {x: width/2, y: height/2 + i*5};
                spine.push(pt);
                tendrilL.push({...pt});
                tendrilR.push({...pt});
            }
            cthulhuCenter = { x: width/2, y: height/2 };

            // 初始化 Shader
            if (!postProcessor) {
                try {
                    if (typeof PostProcessor !== 'undefined') {
                        postProcessor = new PostProcessor(canvas);
                    }
                } catch (e) { console.log("Shader script waiting..."); }
            }
        }

        // 3. ★★★ 关键修改：监听 resize 函数，而不是 init ★★★
        window.addEventListener('resize', resize);
    window.addEventListener('keydown', e => { if(e.key.toLowerCase()=='h') panel.classList.toggle('hidden'); });
    inpFood.addEventListener('input', e => { config.maxFood = parseInt(e.target.value); valFood.innerText = config.maxFood; });
    inpExp.addEventListener('input', e => { config.expPerStage = parseInt(e.target.value); valExp.innerText = config.expPerStage; updateUI(); });

    // --- 鼠标点击逻辑 ---
    window.addEventListener('mousedown', e => {
        if(audio) audio.init(); // 激活音频

        if (foods.length < config.maxFood) {
            foods.push({ x: e.clientX, y: e.clientY, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, r: 6 });
            let color = stage >= 5 ? '#f03' : '#fff';
            spawnExplosion(e.clientX, e.clientY, 8, color);

            if(audio) audio.playSpawn(); // 播放音效
        }
    });

    // --- 切换阶段逻辑 ---
    window.setStage = function(idx) {
        stage = idx; currentExp = 0; updateUI();
        stageBtns.forEach((btn, i) => btn.classList.toggle('active', i === idx));

        let scale = idx === 6 ? 1.2 : (idx === 5 ? 1.1 : 1.05);
        document.body.style.transform = `scale(${scale})`;
        setTimeout(() => document.body.style.transform = `scale(1)`, 250);

        // ★★★ 修复：每次切换阶段都重置爆炸状态，这样到了第7级肯定会炸 ★★★
        hasDescended = false;

        if (!stages[idx].CthulhuForm) {
            morphFactor = 0;
        }

        if(audio) audio.setStage(idx);
    };

    function updateUI() {
        uiStage.innerText = `Phase ${["I","II","III","IV","V", "VI", "VII"][stage]}: ${stages[stage].name}`;
        let titleColor = stage === 6 ? '#f22' : `hsl(${stages[stage].hue}, 100%, 70%)`;
        uiTitle.style.color = titleColor;
        uiTitle.style.textShadow = stage === 6 ? `0 0 20px #f00` : `0 0 10px ${titleColor}`;
        uiExp.style.width = `${Math.min(100, (currentExp / config.expPerStage) * 100)}%`;
    }

    function lerp(start, end, amt) { return (1-amt)*start + amt*end; }
    function spawnExplosion(x, y, count, color) {
        for(let i=0; i<count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1.0, size: Math.random()*3, color, drag: 0.95 });
    }
    function spawnShockwave(x, y) {
        shockwaves.push({ x, y, r: 10, life: 1.0, width: 20 });
    }

    function triggerDescentBurst() {
        hasDescended = true;

        // ★★★ 新增这一行：播放降临音效 ★★★
        if(audio) audio.playDescent();

        flashOverlay.style.transition = 'none'; flashOverlay.style.opacity = 1;
        setTimeout(() => { flashOverlay.style.transition = 'opacity 2.5s ease-out'; flashOverlay.style.opacity = 0; }, 50);
        spawnShockwave(cthulhuCenter.x, cthulhuCenter.y - 100);
        foods.forEach(f => { f.vx = (f.x - cthulhuCenter.x) * 0.2; f.vy = (f.y - cthulhuCenter.y) * 0.2; });
        spawnExplosion(cthulhuCenter.x, cthulhuCenter.y - 100, 200, '#f00');
    }

    function update() {
        time += 0.03;
        let target = stages[stage];
        for(let key in render) if (typeof render[key] === 'number') render[key] = lerp(render[key], target[key], 0.04);
        let dh = target.hue - render.hue;
        if (dh > 180) dh -= 360; if (dh < -180) dh += 360;
        render.hue += dh * 0.05;

        if (stage === 6) {
            morphFactor = lerp(morphFactor, 1, 0.1);
            if (morphFactor > 0.8 && !hasDescended) triggerDescentBurst();
        } else {
            morphFactor = lerp(morphFactor, 0, 0.1);
        }

        let wormHeadTarget = {x: 0, y: 0};
        if (morphFactor > 0.01) {
            wormHeadTarget.x = width/2; wormHeadTarget.y = height/2 - 100;
        } else if (foods.length > 0) {
            wormHeadTarget.x = foods[0].x; wormHeadTarget.y = foods[0].y;
        } else {
            let range = 200 + stage * 60;
            wormHeadTarget.x = width/2 + Math.sin(time*0.4)*Math.cos(time*0.1)*range*1.5;
            wormHeadTarget.y = height/2 + Math.cos(time*0.2)*range;
        }
        updateWormPhysics(wormHeadTarget);

        if (morphFactor > 0.001) updateCthulhuAndBlend();

        updateFoods();
        updateShockwaves();

        particles.forEach((p,i) => {
            p.x+=p.vx; p.y+=p.vy; p.life-=0.02;
            p.vx *= (p.drag||0.99); p.vy *= (p.drag||0.99);
            if(p.life<=0) particles.splice(i,1);
        });
    }

    function updateShockwaves() {
        for (let i = shockwaves.length - 1; i >= 0; i--) {
            let s = shockwaves[i];
            s.r += 15; s.width *= 0.95; s.life -= 0.02;
            if(s.life <= 0) shockwaves.splice(i, 1);
        }
    }

    function updateFoods() {
        for (let i = foods.length - 1; i >= 0; i--) {
            let f = foods[i]; f.x += f.vx; f.y += f.vy;
            if(f.x<0||f.x>width) f.vx*=-1; if(f.y<0||f.y>height) f.vy*=-1;

            let attractPoint = stage === 6 ? cthulhuCenter : spine[0];
            let dx = attractPoint.x - f.x, dy = attractPoint.y - f.y, d = Math.sqrt(dx*dx+dy*dy);

            let attract = stage === 6 ? 0.015 : (stage >= 5 ? 0.01 : 0.003);
            if(d < (stage===6 ? 800 : 500)) { f.vx += dx * attract; f.vy += dy * attract; }

            let eatDist = stage === 6 ? 150 : (30 + render.width);
            if(d < eatDist) {
                foods.splice(i, 1);
                let pColor = stage >= 5 ? '#f03' : `hsl(${render.hue}, 100%, 80%)`;
                spawnExplosion(f.x, f.y, 30, pColor);

                if(audio) audio.playEat(); // 进食音效

                if (++currentExp >= config.expPerStage && stage < 6) setStage(stage + 1); else updateUI();
            }
        }
    }

    // 物理引擎
    function updateWormPhysics(target) {
        let head = spine[0];
        let dx = target.x - head.x, dy = target.y - head.y, angle = Math.atan2(dy, dx);

        // 修复后的速度逻辑：确保变形时有足够的吸力
        let speedBase;
        if (morphFactor > 0.01) {
             // 变形中，吸力随变形因子指数级增加，确保被吸住
             speedBase = 15 * morphFactor + 3;
        } else {
             // 正常游动
             speedBase = (stage === 5 ? 2.5 : (3 + stage * 0.5));
        }

        let speed = speedBase * (foods.length > 0 ? 2 : 1);
        head.x += Math.cos(angle) * speed; head.y += Math.sin(angle) * speed;

        let spacing = 6 + stage;
        for (let i = 1; i < spine.length; i++) {
            let curr = spine[i], prev = spine[i-1];
            let dx = prev.x - curr.x, dy = prev.y - curr.y, d = Math.sqrt(dx*dx+dy*dy), a = Math.atan2(dy, dx);
            if (d > spacing) { curr.x += Math.cos(a)*(d-spacing); curr.y += Math.sin(a)*(d-spacing); }
        }
    }

    function updateCthulhuAndBlend() {
        cthulhuCenter.x = width/2 + Math.sin(time * 0.5) * 30;
        cthulhuCenter.y = height/2 + Math.cos(time * 0.3) * 20;
        for (let i = 0; i < spine.length; i++) {
            let p = spine[i];
            let idealX, idealY;
            if (i < 15) {
                let angle = (i / 15) * Math.PI * 2;
                let radius = render.headSize * (1 + Math.sin(time*2 + i)*0.1);
                idealX = cthulhuCenter.x + Math.cos(angle) * radius * 0.5;
                idealY = cthulhuCenter.y - 100 + Math.sin(angle) * radius * 0.8 + i*2;
            } else {
                let bodyIndex = i - 15;
                let progress = bodyIndex / (spine.length - 15);
                idealX = cthulhuCenter.x + Math.sin(time + i*0.1) * 10;
                idealY = cthulhuCenter.y - 80 + bodyIndex * 6;
            }
            let shake = morphFactor < 1 ? (Math.random()-0.5)*20 * morphFactor : 0;
            p.x = lerp(p.x, idealX + shake, morphFactor);
            p.y = lerp(p.y, idealY + shake, morphFactor);
        }
    }

    function draw() {
        if (stage === 6) {
            let flick = Math.random() < 0.05 ? 0.1 : 0.02;
            ctx.fillStyle = `rgba(${50*flick}, 0, 0, ${0.8-flick})`;
        } else if (stage === 5) ctx.fillStyle = 'rgba(5, 10, 5, 0.5)';
        else ctx.fillStyle = 'rgba(2, 2, 2, 0.6)';

        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'lighter';

        let mainColor = `hsla(${render.hue}, ${render.sat}%, ${render.light}%, 1)`;

        drawShockwaves();
        if (render.tendrilLen > 5) drawSmoothedTendrils();

        ctx.fillStyle = '#fff';
        foods.forEach(f => {
            ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 20; ctx.shadowColor = stage >= 5 ? '#f00' : '#fff'; ctx.stroke(); ctx.shadowBlur = 0;
        });
        particles.forEach(p => {
            ctx.fillStyle = p.color || `hsla(${render.hue}, 100%, 70%, ${p.life})`;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size || 2, 0, Math.PI*2); ctx.fill();
        });

        ctx.strokeStyle = mainColor;
        ctx.lineCap = 'round';
        if (render.glow > 0) { ctx.shadowBlur = render.glow; ctx.shadowColor = mainColor; }

        let startLegIndex = morphFactor > 0.5 ? 30 : 0;
        for (let i = startLegIndex; i < spine.length; i++) {
            let curr = spine[i], prev = spine[Math.max(0, i-1)];
            let angle = Math.atan2(curr.y - prev.y, curr.x - prev.x);
            if (morphFactor > 0) {
                let targetAngle = Math.PI / 2;
                let diff = targetAngle - angle;
                if (diff > Math.PI) diff -= Math.PI * 2;
                if (diff < -Math.PI) diff += Math.PI * 2;
                angle += diff * morphFactor;
            }
            let swing = Math.sin(i * 0.3 - time * 6) * 0.5;
            let shape = Math.sin((i / spine.length) * Math.PI);
            let breath = (stage >= 5 ? Math.sin(time * 10 + i * 0.5) * 3 : 0);
            let wormRad = render.headSize * 0.7;
            let cthulhuRad = (i<15 ? render.headSize*1.5 : render.width*2.5);
            let baseRad = lerp(wormRad, cthulhuRad, morphFactor);
            let radius = baseRad * shape + (3 + stage * 1.5) + breath;
            if(i===0) radius = render.headSize + breath;
            drawSegment(curr.x, curr.y, angle, swing, shape, radius, i);
        }

        drawHollowBody();

        if (render.faceTentacles > 0.1) {
            let headAnchor = morphFactor > 0.5 ? spine[7] : spine[0];
            let neckAnchor = morphFactor > 0.5 ? {x: headAnchor.x, y: headAnchor.y + 10} : spine[1];
            drawFacialTentacles(headAnchor, neckAnchor);
        }

        ctx.shadowBlur = 0; ctx.globalCompositeOperation = 'source-over';

        // ★★★  在这里插入 Shader 渲染逻辑 ★★★
        let distortion = 0;
        if (stage === 4) distortion = 0.2; // DIVINE: 轻微扭曲
        if (stage === 5) distortion = 0.5; // ABOMINATION: 明显扭曲
        if (stage === 6) distortion = 1.5 + (hasDescended ? 0.5 : 0); // CTHULHU: 严重扭曲 + 爆发

        // 变形过程中也会产生扭曲
        if (morphFactor > 0) distortion += morphFactor * 0.5;

        // 执行 Shader 渲染
        if (postProcessor) postProcessor.render(time, distortion);

        // 请求下一帧 (这一行本来就有)
        requestAnimationFrame(() => { update(); draw(); });
    }


    function drawShockwaves() {
        ctx.lineWidth = 5;
        shockwaves.forEach(s => {
            ctx.strokeStyle = `rgba(255, 255, 255, ${s.life})`;
            ctx.lineWidth = s.width;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
            ctx.stroke();
        });
    }

    function drawFacialTentacles(head, neck) {
        let angle = Math.atan2(head.y - neck.y, head.x - neck.x);
        ctx.strokeStyle = stage === 6 ? `hsla(0, 80%, 40%, 0.6)` : `hsla(${render.hue}, 80%, 60%, 0.8)`;
        ctx.lineWidth = stage === 6 ? 4 : 2;
        let count = stage === 6 ? 16 : 8;
        for(let i=-count/2; i<=count/2; i+=0.5) {
            if(i===0 && stage !== 6) continue;
            ctx.beginPath(); ctx.moveTo(head.x, head.y);
            let tLen = (stage === 6 ? 150 : 40) * render.faceTentacles;
            let curl = Math.sin(time * (stage===6?2:5) + i) * (stage===6?40:15);
            let spread = stage === 6 ? i * 0.2 : i * 0.5;
            let cpX = head.x + Math.cos(angle + spread) * tLen * 0.5;
            let cpY = head.y + Math.sin(angle + spread) * tLen * 0.5;
            let endX = head.x + Math.cos(angle + spread*0.8) * tLen + Math.cos(time*3+i)*10;
            let endY = head.y + Math.sin(angle + spread*0.8) * tLen + Math.sin(time*3+i)*10;
            ctx.quadraticCurveTo(cpX + curl, cpY + curl, endX, endY);
            ctx.stroke();
        }
    }

    function drawHollowBody() {
        let leftPoints = [], rightPoints = [];
        for (let i = 0; i < spine.length; i++) {
            let curr = spine[i];
            let next = spine[Math.min(i + 1, spine.length - 1)];
            let prev = spine[Math.max(0, i - 1)];
            let angle = Math.atan2(next.y - prev.y, next.x - prev.x);
            if (morphFactor > 0) {
                let targetAngle = Math.PI / 2;
                let diff = targetAngle - angle;
                if (diff > Math.PI) diff -= Math.PI * 2;
                if (diff < -Math.PI) diff += Math.PI * 2;
                angle += diff * morphFactor;
            }
            let nx = Math.cos(angle + Math.PI / 2), ny = Math.sin(angle + Math.PI / 2);
            let shape = Math.sin((i / spine.length) * Math.PI);
            let breath = (stage >= 5 ? Math.sin(time * 8 + i * 0.3) * (stage===6?8:2) : 0);
            let wormRad = render.headSize*0.6;
            let cthulhuRad = (i<15 ? render.headSize*1.5 : render.width*2.5);
            let baseRad = lerp(wormRad, cthulhuRad, morphFactor);
            let radius = baseRad * shape + (3 + stage * 2) + breath;
            if (i === 0 && stage !== 6) radius = render.headSize + breath;
            let jx = (Math.random()-0.5) * render.chaos;
            let jy = (Math.random()-0.5) * render.chaos;
            leftPoints.push({ x: curr.x + nx * radius + jx, y: curr.y + ny * radius + jy });
            rightPoints.push({ x: curr.x - nx * radius + jx, y: curr.y - ny * radius + jy });
        }
        if(stage === 6) ctx.strokeStyle = 'rgba(200, 50, 50, 0.8)';
        else if(stage === 5) ctx.strokeStyle = 'rgba(100, 255, 100, 0.8)';
        else ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = stage === 6 ? 4 : 2;
        ctx.shadowBlur = 15; ctx.shadowColor = stage === 6 ? '#f00' : (stage === 5 ? '#0f0' : '#fff');
        ctx.beginPath(); ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
        for (let i = 1; i < spine.length; i++) ctx.lineTo(leftPoints[i].x, leftPoints[i].y);
        ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rightPoints[0].x, rightPoints[0].y);
        for (let i = 1; i < spine.length; i++) ctx.lineTo(rightPoints[i].x, rightPoints[i].y);
        ctx.stroke();

        let head = spine[0];
        let headAngle = Math.atan2(spine[1].y - head.y, spine[1].x - head.x);
        if(morphFactor > 0.8) headAngle = Math.PI/2;
        ctx.beginPath(); ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
        let cpYOff = stage === 6 ? -render.headSize : render.headSize * 0.8;
        ctx.quadraticCurveTo(head.x, head.y + cpYOff, rightPoints[0].x, rightPoints[0].y);
        ctx.stroke();
        let last = spine.length - 1;
        ctx.beginPath(); ctx.moveTo(leftPoints[last].x, leftPoints[last].y);
        ctx.lineTo(rightPoints[last].x, rightPoints[last].y); ctx.stroke();

        if (stage <= 5) {
             ctx.shadowBlur = 30; ctx.fillStyle = stage === 5 ? '#f00' : '#fff';
             ctx.beginPath(); ctx.arc(head.x, head.y, render.headSize * 0.4, 0, Math.PI*2); ctx.fill();
        }
        if (stage >= 5) {
            ctx.fillStyle = '#f00'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
            let eyeStep = stage === 6 ? 3 : 8; let eyeChance = stage === 6 ? 0.3 : 0.1;
            for(let i=5; i<spine.length-5; i+=eyeStep) {
                if (Math.random() < eyeChance) {
                    let p = spine[i]; let offX = stage === 6 ? (Math.random()-0.5)*render.width*3 : 0;
                    ctx.beginPath(); ctx.arc(p.x + offX, p.y, stage===6?4:2, 0, Math.PI*2); ctx.fill();
                }
            }
        }
    }

    function drawSmoothedTendrils() {
        ctx.lineWidth = 1;
        let anchorIdx = morphFactor > 0.5 ? 15 : 0;
        updateAndDrawSingleTendril(tendrilL, 1, anchorIdx);
        updateAndDrawSingleTendril(tendrilR, -1, anchorIdx);
    }

    function updateAndDrawSingleTendril(pointsArray, side, anchorIdx) {
        ctx.beginPath();
        if (stage === 6) ctx.strokeStyle = `hsla(0, 100%, 30%, 0.2)`;
        else if (stage === 5) ctx.strokeStyle = `hsla(${render.hue}, 100%, 40%, 0.4)`;
        else ctx.strokeStyle = `hsla(${render.hue}, 100%, 80%, 0.4)`;

        let anchor = spine[anchorIdx];
        pointsArray[0].x = anchor.x; pointsArray[0].y = anchor.y;
        ctx.moveTo(pointsArray[0].x, pointsArray[0].y);

        for (let i = 1; i < spine.length; i++) {
            let spineIdx = Math.min(anchorIdx + i, spine.length - 1);
            let curr = spine[spineIdx];
            let prev = spine[Math.max(0, spineIdx-1)];
            let angle = Math.atan2(curr.y - prev.y, curr.x - prev.x);
            if(stage === 6 || morphFactor > 0.5) angle = Math.PI/2;

            let nx = Math.cos(angle + Math.PI/2), ny = Math.sin(angle + Math.PI/2);
            let progress = i / spine.length;
            let spread = Math.pow(progress, 0.7);
            let waveSpeed = stage >= 5 ? 8 : 3;
            let waveAmp = stage === 6 ? 150 : (stage === 5 ? 80 : 50);
            let wave = Math.sin(i * 0.15 - time * waveSpeed) * waveAmp;
            let baseLen = stage === 6 ? render.tendrilLen * 1.5 : render.tendrilLen;
            let len = render.legLen + (baseLen * spread) + wave;
            let targetX = curr.x + nx * len * side, targetY = curr.y + ny * len * side;
            let chaosLevel = stage === 6 ? 30 : (stage === 5 ? 10 : 0);
            targetX += (Math.random()-0.5)*chaosLevel; targetY += (Math.random()-0.5)*chaosLevel;

            let elasticity = 0.04 + progress * 0.26;
            pointsArray[i].x += (targetX - pointsArray[i].x) * elasticity;
            pointsArray[i].y += (targetY - pointsArray[i].y) * elasticity;
            let p0 = pointsArray[i-1], p1 = pointsArray[i];
            let midX = (p0.x + p1.x) / 2, midY = (p0.y + p1.y) / 2;
            if (i === 1) ctx.lineTo(midX, midY); else ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);

            if (render.tendrilLen > 150 && Math.random() < (0.1 + progress*0.3)) {
                let pColor;
                if(stage === 6) pColor = Math.random() > 0.7 ? '#f00' : '#000';
                else if(stage === 5) pColor = Math.random() > 0.5 ? '#f00' : '#0f0';
                else pColor = `hsla(${render.hue}, 90%, 90%, ${1-progress*0.5})`;
                particles.push({ x: pointsArray[i].x, y: pointsArray[i].y, vx: nx*side*(Math.random()*2), vy: ny*side*(Math.random()*2), life: Math.random()*0.5+0.5, size: Math.random()*2.5, drag: 0.97, color: pColor });
            }
        }
        let last = pointsArray[spine.length-1]; ctx.lineTo(last.x, last.y); ctx.stroke();
    }

    function drawSegment(x, y, bodyAngle, swing, shapeFactor, bodyRadius, index) {
        if(morphFactor > 0.8 && index < 30) return;
        let nx = Math.cos(bodyAngle + Math.PI/2), ny = Math.sin(bodyAngle + Math.PI/2);
        let startLX = x + nx * bodyRadius, startLY = y + ny * bodyRadius;
        let startRX = x - nx * bodyRadius, startRY = y - ny * bodyRadius;
        let len = render.legLen * shapeFactor;
        if (stage === 4) len *= 1.2;
        if (stage >= 5) len *= 0.6;
        let lAngle = bodyAngle+Math.PI/2+swing, rAngle = bodyAngle-Math.PI/2+swing;
        let lx = startLX+Math.cos(lAngle)*len, ly = startLY+Math.sin(lAngle)*len;
        let rx = startRX+Math.cos(rAngle)*len, ry = startRY+Math.sin(rAngle)*len;
        let cx1 = startLX+nx*len*0.3, cy1 = startLY+ny*len*0.3, cx2 = startRX-nx*len*0.3, cy2 = startRY-ny*len*0.3;
        let jitter = (Math.random()-0.5)*render.chaos*2;
        ctx.lineWidth = stage >= 5 ? 2.5 : 1.5;
        if (stage === 6) ctx.strokeStyle = `hsla(0, 100%, 30%, 0.4)`;
        else if (render.tendrilLen > 150 && stage !== 5) ctx.strokeStyle = `hsla(${render.hue}, 100%, 85%, 0.2)`;
        else ctx.strokeStyle = `hsla(${render.hue}, 80%, 60%, 1)`;
        ctx.beginPath(); ctx.moveTo(startLX, startLY); ctx.quadraticCurveTo(cx1+jitter, cy1+jitter, lx+jitter, ly+jitter); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(startRX, startRY); ctx.quadraticCurveTo(cx2+jitter, cy2+jitter, rx+jitter, ry+jitter); ctx.stroke();
        if (render.spike > 0.1) {
            let spikeLen = 10 * render.spike;
            ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx-Math.cos(bodyAngle)*spikeLen, ly-Math.sin(bodyAngle)*spikeLen); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx-Math.cos(bodyAngle)*spikeLen, ry-Math.sin(bodyAngle)*spikeLen); ctx.stroke();
        }
    }

    init(); draw();
</script>
</body>
</html>
